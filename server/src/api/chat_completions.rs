//! Responsible for creating the json schema associated with the AtomaAPI, which is modeled after OpenAPI.

use schemars::JsonSchema;
use serde::{Serialize, Deserialize};

// NOTE: `Role`, `Message` and `content` in some of the `Message`s have sort of a strange
// relationship, ie. `content` is sometimes a struct, sometimes a string or an array, and
// `Message` is expected to be a struct, but is defined as if it should be an enum even though
// the `Role` is defining the type of `Message`. This may need some clarification either via
// documentation to distinguish the differences between the OpenAPI and AtomaAPI, or further
// work to make them the same.

/// ID of the model to use.
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "model", deserialize = "model"))]
pub enum Model {
    #[serde(rename(serialize = "llama3", deserialize = "llama3"))]
    Llama3,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "role", deserialize = "role"))]
pub enum Role {
    /// The role of the messages author, in this case system.
    #[serde(rename(serialize = "system", deserialize = "system"))]
    System,
    /// The role of the messages author, in this case user.
    #[serde(rename(serialize = "user", deserialize = "user"))]
    User,
    /// The role of the messages author, in this case assistant.
    #[serde(rename(serialize = "assistant", deserialize = "assistant"))]
    Assistant,
    /// The role of the messages author, in this case tool.
    #[serde(rename(serialize = "tool", deserialize = "tool"))]
    Tool,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "message", deserialize = "message"))]
pub enum Message {
    #[serde(rename(serialize = "system", deserialize = "system"))]
    System {
        /// The role of the messages author, in this case system.
        role: Role,
        /// The contents of the system message.
        content: String,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        name: Option<String>,
    },
    #[serde(rename(serialize = "user", deserialize = "user"))]
    User {
        /// The role of the messages author, in this case user.
        role: Role,
        /// The contents of the user message.
        content: MessageContent,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        name: Option<String>,
    },
    #[serde(rename(serialize = "assistant", deserialize = "assistant"))]
    Assistant {
        /// The role of the messages author, in this case assistant.
        role: Role,
        /// The contents of the assistant message. Required unless tool_calls is specified.
        content: String,
        /// An optional name for the participant. Provides the model information to differentiate between participants of the same role.
        name: Option<String>,
        /// The refusal message by the assistant.
        refusal: Option<String>,
        /// The tool calls generated by the model, such as function calls.
        tool_calls: Vec<ToolCall>,
    },
    #[serde(rename(serialize = "tool", deserialize = "tool"))]
    Tool {
        /// The role of the messages author, in this case tool.
        role: Role,
        /// The contents of the tool message.
        content: String,
        /// Tool call that this message is responding to.
        tool_call_id: String,
    },
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "content", deserialize = "content"))]
pub enum MessageContent {
    /// The text contents of the message.
    #[serde(rename(serialize = "text", deserialize = "text"))]
    Text(String),
    /// An array of content parts with a defined type, each can be of type text or image_url when passing in images.
    /// You can pass multiple images by adding multiple image_url content parts. Image input is only supported when using the gpt-4o model.
    #[serde(rename(serialize = "array", deserialize = "array"))]
    Array(Vec<MessageContentPart>),
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "content_part", deserialize = "content_part"))]
pub enum MessageContentPart {
    #[serde(rename(serialize = "text", deserialize = "text"))]
    Text {
        /// The type of the content part.
        #[serde(rename(serialize = "type", deserialize = "type"))]
        r#type: String,
        /// The text content.
        text: String,
    },
    #[serde(rename(serialize = "image", deserialize = "image"))]
    Image {
        /// The type of the content part.
        #[serde(rename(serialize = "type", deserialize = "type"))]
        r#type: String,
        image_url: MessageContentPartImageUrl,
    },
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "image_url", deserialize = "image_url"))]
pub struct MessageContentPartImageUrl {
    /// Either a URL of the image or the base64 encoded image data.
    url: String,
    /// Specifies the detail level of the image.
    detail: Option<String>,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "tool_call", deserialize = "tool_call"))]
pub struct ToolCall {
    /// The ID of the tool call.
    id: String,
    /// The type of the tool. Currently, only function is supported.
    #[serde(rename(serialize = "type", deserialize = "type"))]
    r#type: String,
    /// The function that the model called.
    function: ToolCallFunction,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "function", deserialize = "function"))]
pub struct ToolCallFunction {
    /// The name of the function to call.
    name: String,
    /// The arguments to call the function with, as generated by the model in JSON format.
    /// Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema.
    /// Validate the arguments in your code before calling your function.
    arguments: String,
}

#[derive(Debug, Serialize, Deserialize, JsonSchema)]
#[serde(rename(serialize = "requestBody", deserialize = "requestBody"))]
pub struct RequestBody {
    /// ID of the model to use.
    model: Model,
    /// A list of messages comprising the conversation so far.
    messages: Vec<Message>,
}
impl RequestBody {
    pub fn model(&self) -> &Model {
        &self.model
    }

    #[cfg(test)]
    pub(crate) fn control() -> Self {
        Self {
            model: Model::Llama3,
            messages: vec![
                Message::System {
                    role: Role::System,
                    content: "test".into(),
                    name: Some("test".into()),
                },
                Message::User {
                    role: Role::User,
                    content: MessageContent::Array(vec![
                        MessageContentPart::Text {
                            r#type: "test".into(),
                            text: "test".into(),
                        },
                        MessageContentPart::Image {
                            r#type: "test".into(),
                            image_url: MessageContentPartImageUrl {
                                url: "https://imgur.com/m6eWDSz".into(),
                                detail: Some("high".into()),
                            },
                        },
                    ]),
                    name: Some("test".into()),
                },
                Message::Assistant {
                    role: Role::Assistant,
                    content: "test".into(),
                    name: Some("test".into()),
                    refusal: None,
                    tool_calls: vec![ToolCall {
                        id: "chatcmpl-123".into(),
                        r#type: "function".into(),
                        function: ToolCallFunction {
                            name: "myFunction".into(),
                            arguments: "{\"key\": \"value\"}".into(),
                        },
                    }],
                },
                Message::Tool {
                    role: Role::Tool,
                    content: "test".into(),
                    tool_call_id: "0".into(),
                },
            ],
        }
    }
}

#[cfg(test)]
pub mod json_schema_tests {
    // TODO: Move check functions to a test utils module.
    //! Note: These tests make use of the `expect_test` crate, and can be updated by
    //! setting `UPDATE_EXPECT=1`.
    use std::{fs::File, io::BufReader};

    use expect_test::{expect_file, ExpectFile};
    use schemars::schema_for;

    use crate::{validate_with_schema, RequestBody};

    /// Used in tandem with a schema file, this will check if there are
    /// changes to the JSON API schema, and show a diff if so.
    /// If there are changes, running the test with `UPDATE_EXPECT=1`
    /// will update the json schema file.
    fn check_schema(schema: &str, expect_file: ExpectFile) {
        expect_file.assert_eq(schema);
    }

    #[test]
    /// Used in tandem with a schema file, this will check if there are
    /// changes to the JSON API schema, and show a diff if so.
    /// If there are changes, running the test with `UPDATE_EXPECT=1`
    /// will update the json schema file.
    fn verify_request_schema() {
        let request_schema = schema_for!(RequestBody);
        let json_request_schema = serde_json::to_string_pretty(&request_schema)
            .expect("failed to parse json schema into str while verifying request schema");
        check_schema(&json_request_schema, expect_file!["../../request_schema.json"]);
    }

    // TODO: Add the above test for response_schema

    #[test]
    fn request_schema_control() {
        let schema_path = concat!(env!("CARGO_MANIFEST_DIR"), "/request_schema.json");
        let schema_file = File::open(schema_path).expect("request_schema.json not found, try running the verify_request_schema test with UPDATE_EXPECT=1 and try again.");
        let reader = BufReader::new(schema_file);
        let schema: serde_json::Value =
            serde_json::from_reader(reader).expect("failed to read request schema");
        let request = serde_json::json!(RequestBody::control());
        assert!(
            validate_with_schema(schema, request).is_ok(),
            "Failed to validate control from request schema.\nThe AtomaAPI JSON schema is auto generated by running 'UPDATE_EXPECT=1 cargo test verify_request_schema' and is located in 'models/request_schema.json'."
        );
    }
}

